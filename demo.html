<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Backlot demo</title>

    <style type="text/css">
      body{
        background-color: #050505;
        color: #BEBEBE;
        font-family: arial, sans-serif;
        max-width: 1280px;
        margin: 0px auto;
        padding: 1em;
      }
      #fps_meter{
        position: absolute;
        bottom: 1.2em;
        left: 1.1em;
        width: 200px;
        margin: 0px auto;
        min-height: 3em;
      }
      #game_canvas{
        border: 1px solid #333;
        background-color: #000;
        cursor: none;
        display: block;
        margin: 0px auto;
      }
      #container{
        width: 1280px;
        margin: 0px auto;
        position: relative;
      }
      input {
        padding: 0.1em;
        font-size: 1.2em;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <div id="fps_meter"></div>
      <div id="game">
        <canvas id="game_canvas" width="1280" height="720"></canvas>
      </div>
    </div>

    <script type="text/javascript" src="src/util.js"></script>
    <script type="text/javascript" src="src/meter.js"></script>
    <script type="text/javascript" src="src/cursor.js"></script>
    <script type="text/javascript" src="src/viewport.js"></script>
    <script type="text/javascript" src="src/engine.js"></script>
    <script type="text/javascript" src="src/world/quadtree.js"></script>
    <script type="text/javascript" src="src/world/layer.js"></script>
    <script type="text/javascript" src="src/world.js"></script>
    <script type="text/javascript" src="src/asset_depot.js"></script>
    <script type="text/javascript" src="src/entity.js"></script>
    <script type="text/javascript" src="src/entities/sprite.js"></script>
    <script type="text/javascript" src="src/entities/animation.js"></script>
    <script type="text/javascript" src="src/game.js"></script>

    <script type="text/javascript">
      const game = new Game("game_canvas");
      game.set_fps_meter("fps_meter");

      class Location extends Entity {
        constructor(x, y, radius){
          super(x, y, radius*2, radius*2);
          this.radius = radius;
          this.road_radius = (this.radius+8) * 2.1;
          this.width = this.height = this.road_radius * 2;
          this.road_peers = [];
          this.show_radii = false;
          this.show_peers = true;
          this.solid = true;
        }
        update(dt){
          super.update(dt);
          this.show_radii = false;
        }
        render(ctx){
          ctx.lineWidth = 2;
          if(this.show_radii) this.render_road_radius(ctx);
          if(this.show_peers) this.render_road_peers(ctx);
          ctx.fillStyle = "#FFFFFF";
          ctx.strokeStyle = "#000000";
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, 2*Math.PI);
          ctx.fill();
          ctx.stroke();
        }
        render_road_radius(ctx){            
          ctx.beginPath();
          ctx.setLineDash([5, 3]);
          ctx.strokeStyle = "rgba(255,255,255,0.5)";
          ctx.fillStyle = "rgba(255,255,255,0.10)";
          ctx.arc(0, 0, this.road_radius, 0, 2*Math.PI);
          ctx.stroke();
          ctx.fill();
          ctx.setLineDash([]);
        }
        render_road_peers(ctx){
          ctx.strokeStyle = "#FFFFFF";
          ctx.lineWidth = 1;
          ctx.beginPath();
          this.road_peers.forEach((peer) => {
            ctx.moveTo(0, 0);
            ctx.lineTo(peer.x-this.x, peer.y-this.y);
          });
          ctx.stroke();
        }
        check_collision_against(other_location){
          const distance = Math.sqrt(Math.pow(other_location.x - this.x, 2) + Math.pow(other_location.y - this.y, 2));
          if((other_location.is_player || this.is_player) && distance < this.road_radius + other_location.road_radius){
            this.show_radii = true;
            other_location.show_radii = true;
          }
        }
      }

      class AirportLocation extends Location {
        constructor(x, y, radius){
          super(x, y, radius);
          this.air_radius = (this.radius+24) * 2.8;
          this.air_peers = [];
          this.width = this.height = this.air_radius * 2;
        }
        render_air_radius(ctx){            
          ctx.beginPath();
          ctx.setLineDash([5, 3]);
          ctx.strokeStyle = "rgba(200,200,255,0.6)";
          ctx.fillStyle = "rgba(180,180,255,0.10)";
          ctx.arc(0, 0, this.air_radius, 0, 2*Math.PI);
          ctx.stroke();
          ctx.fill();
          ctx.setLineDash([]);
        }
        render(ctx){
          if(this.show_radii) this.render_air_radius(ctx);
          if(this.show_peers) this.render_air_peers(ctx);
          super.render(ctx);
        }
        render_air_peers(ctx){
          ctx.strokeStyle = "#BBBBFF";
          ctx.beginPath();
          ctx.lineWidth = 3;
          this.air_peers.forEach((peer) => {
            ctx.moveTo(0, 0);
            ctx.lineTo(peer.x-this.x, peer.y-this.y);
          });
          ctx.stroke();
        }
        check_collision_against(other_location){
          super.check_collision_against(other_location);
          const distance = Math.sqrt(Math.pow(other_location.x - this.x, 2) + Math.pow(other_location.y - this.y, 2));
          if((other_location.is_player || this.is_player) && distance < this.air_radius + other_location.air_radius){
            this.show_radii = true;
            other_location.show_radii = true;
          }
        }
      }

      class Capitol extends AirportLocation {
        constructor(x, y){
          super(x, y, 14);
        }
      }

      class Town extends AirportLocation {
        constructor(x, y){
          super(x, y, 10);
        }
      }

      class Village extends Location {
        constructor(x, y){
          super(x, y, 7);
        }
      }

      class Settlement extends Location {
        constructor(x, y){
          super(x, y, 5);
        }
      }

      class Outpost extends Location {
        constructor(x, y){
          super(x, y, 3);
        }
      }

      class Roadsign extends Location {
        constructor(x, y){
          super(x, y, 1);
        }
      }

      class Lighthouse extends AirportLocation {
        constructor(x, y){
          super(x, y, 2);
        }
      }

      game.set_scene({
        world: new World(1280*2, 720*2),

        setup: function(){
          this.add_entity(new Sprite(game.add_image("world.png"), 0, 0, 1280*2, 720*2));
          this.set_current_build_type(Capitol);
          this.locations = [];
          this.game.add_audio("bang1.mp3");
        },

        update: function(dt){
          this.move_player_to_cursor();
          this.player.show_radii = true;
        },

        move_player_to_cursor: function(){          
          let world_coords = game.engine.viewport.viewport_to_world(game.engine.cursor.x, game.engine.cursor.y);
          this.player.x = world_coords[0];
          this.player.y = world_coords[1];
        },

        handle_mouse_button: function(event, pressed){
          if(!pressed) return;

          this.game.audio["bang1.mp3"].currentTime = 0;
          this.game.audio["bang1.mp3"].play();

          let world_coords = game.engine.viewport.viewport_to_world(game.engine.cursor.x, game.engine.cursor.y);
          let new_location = new this.build_type(world_coords[0], world_coords[1]);

          this.locations.forEach((location) => {
            const distance = Math.sqrt(Math.pow(location.x - new_location.x, 2) + Math.pow(location.y - new_location.y, 2));
            if(location.road_radius && new_location.road_radius && distance < location.road_radius + new_location.road_radius){
              location.road_peers.push(new_location);
              new_location.road_peers.push(location);
            }
            if(location.air_radius && new_location.air_radius && distance  < location.air_radius + new_location.air_radius){
              location.air_peers.push(new_location);
              new_location.air_peers.push(location);
            }
          });

          this.locations.push(new_location);
          this.add_entity(new_location);
        },

        handle_key: function(event, pressed){
          if(event.key == "1") this.set_current_build_type(Capitol);
          if(event.key == "2") this.set_current_build_type(Town);
          if(event.key == "3") this.set_current_build_type(Village);
          if(event.key == "4") this.set_current_build_type(Settlement);
          if(event.key == "5") this.set_current_build_type(Outpost);
          if(event.key == "6") this.set_current_build_type(Roadsign);
          if(event.key == "7") this.set_current_build_type(Lighthouse);
        },

        set_current_build_type: function(build_type){
          this.build_type = build_type;
          if(this.player) this.player.dead = true;
          this.player = new build_type(0, 0);
          this.player.show_radii = true;
          this.player.is_player = true;
          this.move_player_to_cursor();
          this.add_player_entity(this.player);
          this.game.engine.viewport.track(this.player);
        }
      });

      game.run();
    </script>

  </body>
</html>
